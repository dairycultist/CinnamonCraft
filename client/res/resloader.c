#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "../../util.c"

// this script is a utility, since must include data object files (images, etc.) in program by formatting the object as C sourcecode (most portable/least effort)

void print_binary(const unsigned char *binary, const int binary_length, const char *var_name) {

	printf("unsigned char %s[] = {", var_name);
	for (int i = 0; i < binary_length; i++) {
		printf("%#x,", *(binary + i));
	}
	printf("};\n\n");
}

void print_ppm_to_binary(const char *ppm_path, const char *var_name) {

	// by default, OpenGL reads texture data with a 4-byte row alignment: https://stackoverflow.com/questions/72177553/why-is-gl-unpack-alignment-default-4
	// it's more efficient, but means this function cannot properly read images whose dimensions aren't a multiple of 4 (fix is simple tho)

	int width, height;

	FILE *file = fopen(ppm_path, "r");

	// read header
	{
		char line[1024];

		fgets(line, 1024, file); // not gonna verify header because I'm lazy and just wanna get this working right now
		fgets(line, 1024, file);
		sscanf(line, "%d %d", &width, &height);
		fgets(line, 1024, file);
	}

	unsigned char *pixels = malloc(width * height * 3);

	// ppms store pixels starting from the top left, but opengl wants them starting from the bottom left, so you need to flip the "layers"
	int i;

	for (i = (width - 1) * height * 3; i >= 0; i -= width * 3) {
		fread(pixels + i, 3, width, file);
	}

	fclose(file);

	print_binary(pixels, width * height * 3, var_name);
}

void print_obj_to_binary(const char *obj_path, const char *var_name) {

	// read obj file
	FILE *file = fopen(obj_path, "r");

	if (file == NULL) {
		printf("File does not exist!");
		return;
	}

	char line[1024];

	EZArray position_data  = {0};
	EZArray normal_data    = {0};
	EZArray texture_data   = {0};
	EZArray composite_data = {0}; // stores combined vertex position, normal, and texture data

	int vertex_count;

	while (fgets(line, 1024, file)) {

		char prefix[8];

		sscanf(line, "%s", prefix);

		if (!strcmp(prefix, "v")) {

			float v[3];
			
			sscanf(line, "v %f %f %f", &v[0], &v[1], &v[2]);

			// obj vertices have reverse xz
			v[0] = -v[0];
			v[2] = -v[2];

			append_ezarray(&position_data, v, sizeof(float) * 3);
		}

		else if (!strcmp(prefix, "vn")) {

			float n[3];
			
			sscanf(line, "vn %f %f %f", &n[0], &n[1], &n[2]);

			// obj vertices have reverse xz
			n[0] = -n[0];
			n[2] = -n[2];

			append_ezarray(&normal_data, n, sizeof(float) * 3);
		}

		else if (!strcmp(prefix, "vt")) {

			float n[2];
			
			sscanf(line, "vt %f %f", &n[0], &n[1]);

			append_ezarray(&texture_data, n, sizeof(float) * 2);
		}

		else if (!strcmp(prefix, "f")) {

			// only works with tris right now (no quads or ngons)

			unsigned int p[3]; // vertex position indices
			unsigned int t[3]; // vertex texture coordinate indices
			unsigned int n[3]; // vertex normal indices
			
			sscanf(line, "f %u/%u/%u %u/%u/%u %u/%u/%u",
				&p[0], &t[0], &n[0],
				&p[1], &t[1], &n[1],
				&p[2], &t[2], &n[2]);

			// convert vertex indices to vertex positions (indices start at 1 for some reason)
			append_ezarray(&composite_data, position_data.data + ((p[0] - 1) * sizeof(float) * 3), sizeof(float) * 3);
			append_ezarray(&composite_data, normal_data.data +   ((n[0] - 1) * sizeof(float) * 3), sizeof(float) * 3);
			append_ezarray(&composite_data, texture_data.data +  ((t[0] - 1) * sizeof(float) * 2), sizeof(float) * 2);

			append_ezarray(&composite_data, position_data.data + ((p[1] - 1) * sizeof(float) * 3), sizeof(float) * 3);
			append_ezarray(&composite_data, normal_data.data +   ((n[1] - 1) * sizeof(float) * 3), sizeof(float) * 3);
			append_ezarray(&composite_data, texture_data.data +  ((t[1] - 1) * sizeof(float) * 2), sizeof(float) * 2);

			append_ezarray(&composite_data, position_data.data + ((p[2] - 1) * sizeof(float) * 3), sizeof(float) * 3);
			append_ezarray(&composite_data, normal_data.data +   ((n[2] - 1) * sizeof(float) * 3), sizeof(float) * 3);
			append_ezarray(&composite_data, texture_data.data +  ((t[2] - 1) * sizeof(float) * 2), sizeof(float) * 2);
			
			vertex_count += 3;
		}
	}

	fclose(file);

	// print composite_data info
	printf("int %s_bytecount = %d;\n", var_name, composite_data.bytecount);
	printf("int %s_vertcount = %d;\n", var_name, vertex_count);
	print_binary(composite_data.data, composite_data.bytecount, var_name);
}

int main() {

	freopen("../src/resources.c", "w", stdout);

	printf("// This file was automagically generated by ../res/resloader.c at linking time. Do not edit it!\n\n");
	print_obj_to_binary("miku.obj", "miku_mesh");
	print_ppm_to_binary("dirt.ppm", "dirt_texture");
	print_ppm_to_binary("minecraft_block_spritemap.ppm", "block_spritemap");

	return 0;
}